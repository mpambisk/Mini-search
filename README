Πρώτη εργασία Προγραμματισμού συστήματος 2018
Χαράλαμπος Κιοσές

Στο φάκελο που σας παραδίδω υπάρχουν τα εξής αρχεία:
source:
	minisearch.cpp , Map.cpp , Trie.cpp , newlist.cpp , Utils.cpp
header:
	List.h , Map.h , Trie.h , newlist.h , Utils.h
Makefile

	Η main βρίσκεται στο minisearch.cpp. Το πρόγραμμα ξεκινάει διαβάζοντας τα απαραίτητα ορίσματα
απο τη γραμμή εντολών. Απαραίτητο για τη σωστή λειτουργία είναι να δωθούν και τα 2(-i filename -K num).
Γίνεται έλεγχος εγκυρότητας και σε περίπτωση που δεν είναι σωστά δωσμένα, το πρόγραμμα τερματίζει.
Στη συνέχεια, ανοίγει το filename και το διαβάζει ολόκληρο με την βοήθεια της getline γεμίζοντας τις
δομές Map και Trie. Αφού τελιώσει, ξεκινάει το διάβασμα απο το stdin. Δυνατές εντολές είναι οι:
/search word1 word2 ...
/df
/df word
/tf
/tf key word
/exit
Σε άλλη περίπτωση ζητάει απο τον χρήστη να ξανά πληκτρολογίσει.

Δομές:
	Map: Είναι ένας πίνακας απο Map_nodes όπου τα map_nodes περιέχουν το id και δείκτη στο κείμενο.
		Ο συγκεκριμμένος πίνακας έχει μέγεθος size και είναι γεμάτες counter θέσεις του κάθε στιγμή.
		Το size αρχικοποιείται με 2 και κάθε φορά που το counter φτάσει το size, ο πίνακας διπλασιάζεται
		με χρήση της realloc() απο την συνάρτηση resize.

	Trie: Περιέχει ενα δείκτη σε ενα Trie_node (root)
		To Trie_node είναι μια δομή που περιέχει εναν δείκτη σε λίστα απο Trie_list_node.
		To Trie_list_node αποθηκεύει ενα γράμμα ,ενα δείκτη σε Trie_node που είναι τα παιδιά του
		συγκεκριμμένου κόμβου καθώς και ενα δείκτη σε μια λιστα απο posting_nodes που ουσιαστικά 
		είναι η posting_list μας και είναι != NULL μόνο όταν πρόκειται  για τέλος λέξης.

				 root
				  |
		-------------------------
		|	[c]->[d]->[h]		|	Trie_node
		-----|----|----|---------
			 |	   \	\
			 |	    \    \                   --------
		----------   \     ----------------->| [i*] |
		| [a]	 |    \                      --------
		---|------     \    -------
		   |            --->| [o] |
		-------------       ---|---
		| [r*]->[t*]|          |
		---|---------       ------------
		   |                | [g*]->[o]|
		--------            ---------|--
		| [d*] |				     |
		--------                  --------
								  | [r*] |
								  --------
		Παριστάνεται απλοποιημένα η δομή του Trie μετά απο την εισαγωγή των cat,dog,car,hi,card,door.
		Οι κόμβοι οι οποίοι περιτριγυρίζονται απο --- και | είναι Trie_node ενώ αυτοί με τις
		[] είναι Trie_list_node. Όσοι Trie_list_node έχουν posting_list != NULL περιέχουν ενα *.
		Όλα τα γράμματα που εμπεριέχονται σε ενα Trie_node έχουν prefix την σειρά γραμμάτων που 
		δημιουργείται απο τα Trie_list_node που με την χρήση του Trie_node * children, οδήγησαν σε
		αυτόν.
		Το posting_list αποτελείται απο posting_nodes που καθένα έχει ενα id, το οποίο αντιστοιχεί σε κείμενο
		που βρέθηκε η λέξη καθώς και ενα frequency που μας λέει πόσες φορές βρέθηκε στο συγκεκριμμένο
		κείμενο.
		Ενδιαφέρον έχουν οι συναρτήσεις Trie::search και Trie::insert. H insert ψάχνει να δεί αν υπάρχει
		το πρώτο γράμμα στο Trie_list_node του Trie_node που δείχνει το root. Aν όχι δημιουργεί ενα νεο
		node με το γράμμα και καλεί την Trie_node::insert απο το παιδί του καινούργιου κόμβου, για το 
		επόμενο γράμμα της λέξης. Όταν φτάσει στο τελευταίο γράμμα δημιουργεί ενα Posting_list. Αν 
		ψάχνοντας το γράμμα σε ενα Trie_list_node δεί οτι ήδη υπάρχει προχωράει για το επόμενο γράμμα στο
		παιδί του. Αν η λέξη ήδη υπάρχει, απλά προσθέτει κόμβους στην posting_list. Η search ψάχνει το 
		δέντρο για μια λίστα απο λέξεις (το πολύ 10)  χρησιμοποιώντας για καθεμία την Trie::word_search()
		με την ίδια λογική που λειτουργεί και η insert(). Επιστρέφει μια λιστα score_node που έχει έναν
		κόμβο για κάθε λέξη εμπεριέχοντας την posting_list της.
		πχ
		---------------------------------     ----------------------------------
		| word ="cat" , [0 1]->[1 2]     |--->| word ="dog",[1 1]->[3 4]->[5 1] |
		---------------------------------     ----------------------------------
		Όπου με [] έιναι τα posting_nodes και με | | τα score_nodes
		Το κάνω αυτό ώστε όταν καλείται η search να βρίσκω εύκολα το nqi της κάθε λέξης.

	Heap:
		Απο τα αρχεία Heap.cpp και Heap.h χρησιμοποιώ τις δομές Heap_array, Heap_array_node.
		Έχω αναπαραστήσει ενα binary max heap με μορφή πίνακά. Ο πίνακας είναι δυναμικός
		και αυξάνεται ή μειώνεται ανάλογα με τις ανάγκες. Διατηρεί μια μεταβλητή height
		όπου κρατάει το μέγιστο ύψος του heap (root height = 0) κάθε φορά που ο πίνακας
		μεγαλώνει προσθέτει ενα επίπεδο βάθους και άρα 2^height κόμβους στον πίνακα.
		Αντίστοιχα όταν μειώνεται κάνει height-- και διαγράφει όλους τους κόμβους που
		είχαν δεσμευτεί στο χαμηλότερο επίπεδο. Οι δύο αυτές λειτουργίες γίνονται με
		τις συναρτήσεις resize και halve που χρησιμοποιούν realloc. Για ενα κόμβο
		heap_array_node του πίνακα που βρίσκεται στην θέση n, τα παιδιά του βρίσκονται
		στις θέσεις 2n+1 και 2n+2. Αντίστοιχα για ενα heap_array_node που βρίσκεται στη
		θέση n του πίνακα του heap ο γονιός του βρίσκεται στη θέση round_down((n-1)/2).
		Η ιδέα είναι απο το https://www.youtube.com/watch?v=fJORlbOGm9Y όπου περιγράφεται
		και πιο αναλυτικά αυτή η λειτουργία.
		Επέλεξα heap_array ώστε να μπορώ να κάνω γρήγορα εισαγωγή insert και διαγραφή του
		μεγαλύτερου (pop) μια και ξέρω αμέσως που έιναι η τελευταία θέση του πίνακα (counter)
		χωρίς να χρειάζεται να ακολουθήσω path σε δέντρο ή να κρατάω παραπάνω πληροφορία.
		Η ταξινόμηση γίνεται με την χρήση της συνάρτησης sort και swap. Τέλος εαν το key 
		που πάω να κάνω insert υπάρχει ήδη στο heap τότε καλώ την update που προσθέτει το
		καινούργιο score στο ήδη υπάρχον του key και καλεί sort. Ο συγκεκριμμένος έλεγχος
		γίνεται στη αρχή της Heap_array::insert.

	Lista<T>: μια template λιστα
	CLista :Μια λίστα με char *. Έφτιαξα και αυτήν την λίστα εκτός απο την template γιατί
	η Lista<T> μου λειτουργούσε καλά με δεδομένα struct ή class. Έγινε καθαρά και μόνο για 
	λόγους ευκολίας.

Λίγο αναλυτικότερα οι λειτουργίες:
	Search:
		Ψάχνει για τις λέξεις που δίνονται στο stdin (μεχρι 10) στο trie χρησιμοποιώντας
		την Trie::search που περιγράφηκε παραπάνω. Αφού πάρει το score_list χρησιμοποιεί
		τις συναρτήσεις του Utils.h για να υπολογίσει το score για κάθε id. Βάζει την πλειάδα
		id,score στο heap με την heap::insert όπου παράγοντας ταξινόμησης είναι το score
		Και κλειδί είναι το id. Στην συνέχεια εξάγει το πολύ τις top κ πλειάδες απο το heap
		και τυπώνει id score και κείμενο που το βρίσκει απο την δομή map.
		Δεν γίνεται εκτύπωση των δεικτών ^^^^ κάτω απο κάθε λέξη που βρέθηκε,ωστόσο οι συναρτήσεις
		find_pos και search_print του Utils.h δημιουργήθηκαν με αυτό τον σκοπό αλλά δεν είναι πλήρεις.
	df:
		Χρησιμοποιεί την Trie::print() για να εκτυπώσει όλο το δέντρο. Η συγκεκριμμένη συνάρτηση δεσμεύει
		μια συμβολοσειρά και με την χρήση της Trie_node::print() βάζει το letter που βρίσκεται σε βάθος i
		του Trie στην i θέση της συμβολοσειράς. Όποτε βρεί posting_list βάζει στην θέσεη i+1 της συμβολοσειράς 
		'\0' την τυπώνει και στην συνέχεια τυπώνει τον αριθμό των κειμένων στο οποίο βρέθηκε η λέξη, το οποίο 
		είναι το counter της posting_list.
	df word:
		Βρίσκει την posting list της λέξης word με χρήση της Trie::word_search() και τυπώνει την λέξη και το 
		counter της posting_list.
	Η df θα μπορούσε να γίνει καλώντας df word  για κάθε word του δέντρου. Η υλοποίηση που επέλεξα θεωρώ οτι
	είναι γρηγορότερη μιας και δεν χρειάζεται να κάνει περιττά δρομολόγια μέσα στο trie. Δηλαδή δεν χρειάζεται 
	για λέξεις που έχουν ίδια prefix να γίνει η διαδρομή στα prefix παραπάνω απο 1 φορά.

	tf id word:
		Χρησιμοποιεί πάλι την Trie::word_search για να βρεί το posting_list της word. Μετά ψάχνει το posting_list
		για το id και αν το βρεί τυπώνει το frequency του συγκεκριμμένου κόμβου.

Compile and link:	make
				g++ -o minisearch *.cpp
Running :	make run (default ορίσματα check Makefile)
			./minisearch -i <somefile> -K <int>
		Μπορεί να γίνει αλλαγή της σειράς των flags αλλά πρέπει πάντα το αρχείο
		να είναι μετά το -i και αριθμός μετά το -K.

make clean: 	delete object files and executable

make valgrind:	Έλεγχος μνήμης, πάλι με default ορίσματα.
Αλλιώς: 
	valgrind --leak-check=yes --show-reachable=yes --track-fds=yes ./minisearch -i <somefile> -K <int>

Έγινε έλεγχος σε διάφορες περιπτώσεις εκτέλεσης όπου δεν παρατηρήθηκαν memory leaks. Χαρακτηριστικά για μια
εκτέλεση ./minisearch -i Entertainment.txt -K 200
/search cat dog car
/search the of if in
/search revised
/search yes no west east north south tall short
/df
/df memory
/df the
/df in
/tf 5 the
/tf 8 on
/tf 50 zxcvbnm
/exit
==15635== HEAP SUMMARY:
==15635==     in use at exit: 72,704 bytes in 1 blocks
==15635==   total heap usage: 694,141 allocs, 694,140 frees, 25,437,968 bytes allocated
==15635== 
==15635== 72,704 bytes in 1 blocks are still reachable in loss record 1 of 1
==15635==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==15635==    by 0x4EC3EFF: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)
==15635==    by 0x40106B9: call_init.part.0 (dl-init.c:72)
==15635==    by 0x40107CA: call_init (dl-init.c:30)
==15635==    by 0x40107CA: _dl_init (dl-init.c:120)
==15635==    by 0x4000C69: ??? (in /lib/x86_64-linux-gnu/ld-2.23.so)
==15635==    by 0x4: ???
==15635==    by 0xFFF00034A: ???
==15635==    by 0xFFF000357: ???
==15635==    by 0xFFF00035A: ???
==15635==    by 0xFFF00036C: ???
==15635==    by 0xFFF00036F: ???
==15635== 
==15635== LEAK SUMMARY:
==15635==    definitely lost: 0 bytes in 0 blocks
==15635==    indirectly lost: 0 bytes in 0 blocks
==15635==      possibly lost: 0 bytes in 0 blocks
==15635==    still reachable: 72,704 bytes in 1 blocks
==15635==         suppressed: 0 bytes in 0 blocks
==15635== 
==15635== For counts of detected and suppressed errors, rerun with: -v
==15635== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Όπου τα 72,704 bytes είναι απο το iostream.
